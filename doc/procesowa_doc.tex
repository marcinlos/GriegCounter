
\newcommand{\Header}[1]
{\vspace*{4pt}\noindent\textbf{#1}\vspace*{2pt}\par}

\chapter{Wstęp}
\section{Cele projektu}
Podstawowym celem jest stworzenie aplikacji mobilnej na urządzenia wyposażone w system Android która
pozwalałaby na badanie w locie różnych właściwości melodii. Funkcjonalności jakie przewidywaliśmy zawierały w sobie wszystko pomiędzy analizowaniem liczby BPM (beats per minute) poprzez rozponawanie instrumentów aż po identyfikację gatunku muzycznego. Napotkane problemy jednak zweryfikowały nasz entuzjazm i przeniosły ciężar projektu na inne tory.

Ostatecznie ze względu na niemożność użycia żadnej gotowej biblioteki naszym celem, oprócz samej aplikacji, stało się stworzenie Frameworku który tworzyłby podwaliny dla budowy aplikacji takich jak nasza. Miał pozwalać na wczytywanie plików muzycznych różnych formatów (wav, mp3, ogg), być łatwo rozszerzalny, oraz pozwalać na elastyczne przetwarzanie danych.
   
\section{Studium wykonalności i analiza ryzyka}

\noindent\emph{Nieznajomość systemu Android} -- W chwili rozpoczęcia projektu żaden z nas nie posiadał żadnego doświadczenia z programowniem na systemy mobilne, w szczególności na system Android. Nie znaliśmy dobrych praktyk, specyfiki i ograniczeń platformy. By temu przeciwdziałać równolegle jako projekt z innego przedmiotu pracowaliśmy również nad aplikacją androidową, w ramach tego projektu zakładaliśmy częste prototypowanie we wczesnych fazach by wyeliminować podstawowe problemy· \emph{Ryzyko: 8/10}

\noindent\emph{Gotowe biblioteki} -- Żaden z nas nie miał doświadczenia w pracy nad plikami dźwiękowymi. Musieliśmy liczyć na to, że będą istniały gotowe biblioteki które obsłużą najniższy poziom i zapewnią podstawową funkcjonalność z którą moglibyśmy się zapoznać i na jej podstawie kontynuowć. W tym celu przeprowadziliśmy iterację 0 której celem było zbadanie istniejących już rozwiązań pod kątem użyteczności dla naszej aplikacji. \emph{Ryzyko: 7/10}

\noindent\emph{Brak wiedzy dziedzinowej} - Muzyka do tej pory interesowała nas głównie w charakterze odbiorców. Nie dysponowaliśmy wiedzą specjalistyczną o sposobie reprezentacji plików dźwiękowych, czy istniejących już sposobach analizy. By temu przeciwdziałać planowaliśmy przyjrzeć się uważnie gotowym implementacjom w isniejących już rozwiązaniach, oraz dokładnie badać każdą propozycję klienta na temat funkcjonalności by określić poziom skomplikowania przed przystąpieniem do implementacji.

\noindent\emph{Praca w zespole} -- charakter członków zespołu mógł okazać się niekompatybilny. Problemy z podziałem pracy i delegacją obowiązków, niepewny zakres odpowiedzialności, problemy związane z zarządzaniem czasem. By temu przeciwdziałać narzuciliśmy sobie sztywną hierarchię, i kładliśmy nacisk na komunikację wewnątrz zespołu na temat wszystkiego związanego z projektem. \emph{Ryzyko: 7/10} 

\chapter{Przyjęta metodyka pracy}

Planem na organizację pracy początkowo była idea iteracji, przyrostowego modelu którego każdy cykl
kończy się gotowym do zaprezentowania klientowi produktem. Po przerzuceniu ciężaru prac na budowę
Frameworku okazało się to jednak w dużej mierze niemożliwe ze względu na jego zawiłą i powiązaną
nawzajem budowę uniemożliwiającą działanie na wynikach cząstkowych. Stąd też jedna z iteracji
zdecydowanie góruje długością nad pozostałymi ponieważ składa się na nią całość implementacji
Frameworku od zera do stanu w którym był on używalny, a API przyjęło ostateczną formę.

\section{Role i podział prac w zespole}

Nasz zespół pracował w ścisłej hierarchii związanej z poziomem umiejętności. Kierownictwo przejął
\emph{Marcin Łoś} -- jako bardziej doświadczony programista to on odpowiada za architekturę frameworku, on też zarządzał projektem delegując zadania gdzie uznał to za stosowne. Jego pomysły są podstawą budowy każdego modułu. \emph{Michał Torba} jako
główną odpowiedzialność przyjął aplikację Androidową oraz dokumentację projektu pełniąc jedynie
pomocniczą funkcję w pozostałych aspektach prac.

\section{Komunikacja w zespole}
Plusem ułatwiającym komunikację w zespole był fakt, że jesteśmy dość dobrymi przyjaciółmi. To ułatwiało organizację. W czasie prac nie doszło do większych spięc na poziomie interpersonalnym, problemy rozwiązywane były na poziomie kulturalnego dyskursu. Dwiema głównymi platformami komunikacji były Google Hangouts używany do dyskusji wszelakich gdy akurat nie mogliśmy się zobaczyć na żywo, oraz opisy commitów. Drugorzędną rolę odgrywała dokumentacja powstająca na Confluence nadająca punkty zaczepienia. Duża część prac, szczególnie w końcowych fazach projektu, odbywała się zaś w sprintach związanych ze spotkaniami na żywo na kilkugodzinnych sesjach wspólnego implementowania.

\section{Komunikacja z klientem i managerem}
W tej płaszczyźnie nie obyło się bez pewnych zgrzytów. Rozpoczęcie projektu odbyło się dosyć gładko, wizja tego co należy zrobić na początek była prosta i zrozumiała. Później napotkaliśmy na pewne zgrzyty związane z organizacją, dwa spotkania były przekładane na inne terminy ze względu na problemy komunikacyjne. Kryzys nastąpił podczas wakacji, gdy na czas implementacji rdzenia Frameworku postęp prac nie był konsultowany. Ostatnie fazy projektu zaowocowały jednak zwiększoną współpracą i doprowadziły nas do szczęśliwego końca.

\section{Wykorzystane narzędzie do zarządzania projektem}
Jako repozytorium kodu wykorzystaliśmy popularny Github. Do szybkiego tworzenia bieżącej dokumentacji projektowej korzystaliśmy z systemu Confluence udostępnianego przez Katedrę Informatyki. Specjalne podziękowanie należy się też Google Hangouts, głównej platformy komunikacji wewnątrz zespołu. Poza tym jednak nie używaliśmy żadnych specjalizowanych narzędzi zarządzania projektem.

\section{Problemy napotkane w trakcie realizacji projektu}
\label{problem}

W czasie realizacji projektu wystąpiło kilka pomniejszych problemów czy zgrzytów do których były nawiązania już wyżej, praktycznie wszystkie były jednak nieistotne w porównaniu z głównym napotkanym problemem:

Android nie implementuje \code{javax.sound}.

Jako programistów nieobeznanych z systemem Android było to nielada zaskoczenie. Miało również poważne konsekwencje. Wszystkie biblioteki z których pomocy planowaliśmy korzystać korzystały z tego pakietu jako integralnej części logiki. Bez niego pozbawieni zostaliśmy możliwości wczytania pliku w sposób nadający się do analizy. Straciliśmy czas na tworzenie planów i rozpoczęcie implementacji na sposób który nie mógł zadziałać.

Rozwiązaniem go była restrukturyzacja (i znaczące rozszerzenie) projektu, czyli rozdzielenie prac na aplikację oraz Grieg, czyli framwork zapewniający nasz własny backend do analizy muzyki bez którego istnienie aplikacji byłoby niemożliwe.

\chapter{Weryfikacja wyników projektu}

\section{Testy jednostkowe}
Zastosowane zostały wewnątrz Frameworku. Do testów jednostkowych wykorzystywany był framework JUnit4 oraz Mockito, sporadycznie także
PowerMock. Nie cały kod został pokryty w pełni testami jednostkowymi; pokrycie wynosi ok. 30\% (do
jego określenia wykorzystane zostało narzędzie EclEmma). Testowane były głównie te fragmenty,
których poprawność jest kwestią delikatną i łatwą do naruszenia, m. in. systemy dynamicznego
ładowania dodatkowej funkcjonalności wraz z parserami konfiguracji, wykorzystywane przez nie klasy
pomocnicze do skanowania CLASSPATH-a i obsługa refleksji, jak również API modeli i klasy
odpowiedzialne za konfigurację. Brak testów jednostkowych dla rdzenia systemu spowodowany jest jego
stabilnością -- po stworzeniu go na samym początku prac implementacyjnych nie był zmieniany.

\section{Testy akceptacyjne}
Aplikacja Androidowa uruchamiana była na kilku różnych emulatorach reprezentujących różne urządzenia oparte o system Android, oraz wykorzystana do przeanalizowania różnych plików muzycznych. Prezentowana była klientowi w ostatecznej formie i została zaakceptowana jako spełniająca jego wymagania.

\chapter{Przebieg prac}

\section{Harmonogram}

\begin{center}
    \begin{tabular}{| l | l | p{9cm} |}
    \hline
    Data rozpoczęcia & Data zakończenia & Opis \\ \hline
    Maj 2013 & Czerwiec 2013 & Iteracja 0 - wstępna analiza, poszukiwanie gotowych rozwiązań, rozważania na temat ostatecznej funkcjonalności. \\ \hline
    Czerwiec 2013 & Lipiec 2013 & Iteracja 1 - rozpoczęcie implementacji. Równoległa implementacja funkcjonalności (pierwsze analizowane rzeczy) w środowisku czysto Javowym w oparciu o bibliotekę \emph{Beads}. Napotkanie na problem z java.sound na Androidzie co zatrzymało dotychczasowe prace. \\ \hline
    Lipiec 2013 & Lipiec 2013 & Iteracja 2 - Kolejna faza projektowania - niezbędna ze względu na poszerzony zakres projektu. Tutaj powstały główne idee oraz szkic API frameworku.  \\ \hline
    Lipiec 2013 & Październik 2013 & Iteracja 3 - Implementacja rdzenia systemu. \\ \hline
    Październik 2013 & Listopad 2013 & Iteracja 4 - Zakończenie prac nad frameworkiem (dodanie gotowych jednostek przetwarzania), stworzenie aplikacji Androidowej z wykorzystaniem Frameworku. \\ \hline
    Listopad 2013 & Styczeń 2014 & Iteracja 5 - Dopracowanie aplikacji oraz opracowanie dokumentacji projektowej. \\ \hline
    \end{tabular}
\end{center}


\section{Iteracja 0}
Nazywana w czasie gdy ją wykonywaliśmy Iteracją 0. Była to pierwsza faza projektu, w której badaliśmy dostępne biblioteki i rozważaliśmy ostateczną funkcjonalność aplikacji do analizy. Trwała bardzo krótko, i zostawiła po sobie zaledwie zarys oraz pomysł. Poniżej notatki na temat znalezionych bibliotek:

\begin{Note}

Istnieje kilka bibliotek które zwróciły naszą uwagę:

\begin{itemize}
  \item Beads -- \url{http://www.beadsproject.net/} -- głównie przeznaczona do generowania włąsnego audio, pozwala jednak na wczytanie plików zewnętrznych (wav only). Wbudowany FFT i inne.
  \item MusicG -- \url{http://code.google.com/p/musicg/} -- biblioteka z wysokim stopniem prawdopodobieństwa działająca na Androidzie (zaznaczone funkcjonalności które tam nie zadziałają). Proste i łatwe w użyciu, dokumentacja jednak szczątkowa, trudne do wykorzystania w naszych celach
  \item Manual:Minim -- \url{http://code.compartmental.net/tools/minim/manual-minim/} -- bazująca na JavaSound API biblioteka do tworzenia, analizy i przetwarzania dźwięku. Obsługuje bezpośrednio kilka podstawowych formatów: WAV, AIFF, AU, SND, MP3, pozwala na odczyt metadanych (np. tagi ID3), zawiera implementację FFT. Posiada również funkcjonalność wykrywania beatów, opartą na wykrywaniu gwałtownych skoków amplitudy.
\end{itemize}

Wybór jednej z nich jest jednak poważną sprawą, i zostanie dokonany już po rozpoczęciu implementacji.

Istnieje też Echo Nest -- \url{http://developer.echonest.com/}. Posiada zamkniętą architekturę
serwerów (dostępne jedynie w formie binarek), jednak szeroki zakres zaawansowanych funkcji do
analizy muzyki (włącznie z identyfikowaniem utworów po footprincie) nie pozwala go ignorować.
Najprawdopodobniej do użytku jako black box jeśli sami nie dokończymy jakiejś funkcjonalności którą
oni implementują (szczególnie jeśli chodzi o identyfikację) -- co oznacza że jest do zostawienia na dalsze iteracje.

\end{Note}

\section{Iteracja 1}
Iteracja podczas której wszystko się stało się bardziej skomplikowane. Początkową implementację rozpoczęliśmy w środowisku
znanym -- czysta Java -- co opóźniło rozpoznanie głównego problemu.

\begin{Note}

\Header{Plany:}

\begin{itemize}
    \item Stworzenie aplikacji w Androidzie z graficznym interfejsem używającej wybranej biblioteki audio
    \item Wczytywanie utworu do analizy w formacie .wav (bądź innymi wspieranymi bezpośrednio przez bibliotekę
    \item Wynikiem powinny być spektrum (w formie wykresu), wykres fali dźwiękowej oraz mocy zależnie od czasu.
\end{itemize}

\Header{Implementacja:}

Rozpoczęcie implementacji, na początku w izolacji pomiędzy interfacem androidowym oraz logiką działania przebiegało pomyślnie. Wybrana przez nas biblioteka Beads sprawdzała się w środowisku javowym, uzyskaliśmy działającą implementację przewidywanej funkcjonalności na tę iterację, dysponujemy również działającym androidowym interfejsem gotowym do podłączenia pod javową logikę. Będąc przekonani, że wszystko pójdzie już gładko przystąpiliśmy do integracji tych dwóch elementów.

\Header{Problemy:}

Okazało się, że w iteracji 0 podczas zapoznawania się z dostępnymi bibliotekami i ich używalnością na Androidzie przeoczyliśmy drobny detal. Większość tych bibliotek (wszystkie których użycie poważnie rozważaliśmy, w tym Beads na który się zdecydowaliśmy) wykorzystuje JavaSound. Android natomiast wbrew naszym oczekiwaniom i milczącym założeniom tego nie obsługuje.

\end{Note}

To był moment opisany już w sekcji problemów(patrz: \ref{problem}). Po nim nastąpił swoisty restart prac

\section{Iteracja 2}
\begin{Note}

\Header{Cel:}

Zaprojektowanie nowej wersji architektury systemu z uwzględnieniem rozdzielenia na Framework i aplikację

\Header{Architektura:}

Projektowaniu architektury przyświecały następujące założenia:
\begin{itemize}

    \item Potrzebujemy w miarę efektywnego broadcastowania dużych ilości danych
    \item Chcemy uniknąć wielokrotnego przeliczania tych samych rzeczy, jednocześnie wiemy że wiele analiz może mieć wspólne cechy i etapy przetwarzania, stąd potrzebujemy sposobu na eleganckie współdzielenie wyników.
    \item Pseudoasynchroniczność w formie rozdzielenia w czasie wejścia i wyjścia -- istnienie różnych formatów dźwięku powoduje, że a priori nie wiemy ile danych należy przeczytać przed stworzeniem wyniku
    \item Elastyczny format wejścia -- chcąć zczytywać dane z mikrofonu niezbędny jest model typu push (będący bardziej ogólnym i wygodnym dla architektury całości systemu), jednocześnie jako wejście akceptujemy też pliki które w swej naturze są raczej pasywne

\end{itemize}

Ze względu na postawione przed nią wymagania architektura systemu nie była prostą sprawą.
Ostatecznie nasze rozwiązanie problemu zostało zainspirowane pracą Olega Kiselyova \cite{kiselyov}, które dzięki swojej konstrukcji spełniało nasze założenia.

Wiemy że wiele węzłów przetwarzania będzie potrzebowało do działania tych samych danych wejściowych
(muzyki) -- idea niezmienności danych zaczerpnięta z programowania funkcyjnego pozwala zaś na eleganckie i bezpieczne dzielenie tego zasobu. Forma modelu, będąca pipelinem w strukturze drzewiastej pozwoli dowolnie łączyć ze sobą wejścia i wyjścia różnych etapów przetwarzania, pozwalając na stosowanie uniwersalnych klocków (takich jak okno Hamminga) by uzyskać dowolną złożoność. Fakt, że dane będą pushowane w dół drzewa sprawia, że każdy indywidualny węzeł ma pełną kontrolę nad wyjściem. Model pull do czytania wejściowych plików z muzyką można w umiarkowanie prosty sposób zasymulować tworząc klasę-przejściówkę.

Każdy węzeł (będący ,,Enumeratee'' w konwencji nazw Kiselyowa) akceptuje wejście o określonym typie danych, i (gdy zdecyduje, że ma dość danych i może je przetworzyć) produkuje wyjście jakiegoś (dowolnego) typu. Można je łączyć w dowolnych, niecyklicznych konfiguracjach uzyskując również w naturalny sposób wiele wyjść do konsumpcji przez GUI.

Wynikiem prac jest pierwsza wersja API systemu wraz z wstępnymi interfejsami dla parserów plików

\end{Note}

\section{Iteracja 3}

\begin{Note}

\Header{Cel:}
	Implementacja rdzenia Frameworka

\Header{Implementacja:}

Rdzeń systemu to bardzo ogólne pojęcie, i celowo -- na tą iterację składają się dziesiątki różnego rodzaju klas i funkcjonalności, między innymi:

\begin{itemize}
    \item obsługa dynamicznej konfiguracji parserów --  każdy parser opisany będzie własnym plikiem konfiguracyjnym. Architektura androida dyskwalifikuje jednak standardową metodę dołączenia takiego parsera w formie jar który zawierałby w sobie plik konfiguracyjny o standardowej nazwie, ze względu na jego tendencję do zbijania wszystkiego w jeden wspólny dex. Ominięcie tego nie tracąc jednocześnie pluginowej addytywności (czyli dodanie nowego parsera bez potrzeby edycji istniejącego kodu, w tym istniejącej konfiguracji) wymagała napisania własnego skanera classpatha.
    \item sposób sparsowania tych plików konfiguracyjnych -- odczytujemy z nich główną klasę parsera oraz deklarowane rozszerzenia które jest w stanie odczytać.
    \item klasy z których zbudowany będzie Pipeline
\end{itemize}

Sam Pipeline -- to nasz type-safe Wrapper opakowujący drzewo przetwarzania. Samo drzewo zaś składa
się z jednego korzenia (Enumeratora -- aktywne źródło danych) rozgałęziającego się na wiele węzłów
(będących albo Enumeratee -- węzeł posiadający pasywne wejście oraz aktywne wyjście -- oraz Iteratee
-- liście posiadające jedynie wejście). Jego elementy są identyfikowane po (unikalnych globalnie) nazwach. Wykorzystuje również class-tokeny by zachować type-safety przy definiowaniu typów wejścia oraz wyjścia. Podpinanie nowych elementów definiowane jest deklaratywnie z myślą o jak najłatwiejszym podpinanie całej konfiguracji drzewa za pomocą plików xml w przyszłości, zgodne jest też z zasadami Fluent API.

Droga przez którą przechodzi plik wygląda następująco:

\begin{itemize}
    \item Tworzony jest Processor (klasa reprezentująca cały proces dla jednego źródła danych)
    \item Wczytujemy plik
    \item Wybierany jest parser (na podstawie rozszerzenia)
    \item Wstępna analiza -- listenery są odpytywane (signalBeforePreAnalysis) o cechy które powinny zdobyć przed analizą właściwą (umieszczają je w kontekście), takie jak długość utworu, Processor wyciąga te informacje (preAnalysis) i zwraca je również za pomocą kontekstu (signalAfterPreAnalysis)
    \item Rozpoczyna się analiza właściwa (wchodzimy do Pipelina), i tam też się kończy.
\end{itemize}

Implementacja parserów to również spory kawałek roboty. Dla ujednolicenia wszystkie parsowane pliki transformowane są do formatu PCM, i w takiej formie będą dalej przetwarzane. Parser mp3 na szczęście udało się zrobić przy wykorzystaniu gotowej biblioteki JLayer (omijającej JavaSound).

\end{Note}

\section{Iteracja 4}

\begin{Note}

\Header{Cel:}

\begin{itemize}
    \item implementacja jednostek przetwarzania
    \item implementacja aplikacji Androidowej w oparciu o framework
\end{itemize}

\Header{Wynik:}
Zaimplementowane zostały wszystkie węzły przetwarzania gotowe w ostatecznej wersji frameworku (do zobaczenia w dokumentacji technicznej). W tym momencie stan frameworku zostaje zawieszony do czasu zakończenia pozostałej części pracy inżynierskiej.

Wynikowa aplikacja Androidowa dostaje swoją pierwszą implementację. Nie jest w żaden sposób
dopieszczona pod względem estetycznym, preprocessing po prostu zawiesza kontrolę nad aplikacją,
użytkownik nie ma żadnej możliwości wyboru a kończenie jej wymaga zabijania aplikacji z poziomu
ustawień Androida -- natomiast wszystkie wykresy rysują się tak jak powinny co spełnia postawiony przed nią cel.

\end{Note}

\section{Iteracja 5}

\begin{Note}

Ostatnia iteracja. 

\Header{Cel:}

\begin{itemize}
    \item Dopracować aplikację androidową -- poprawić wygląd, dodać możliwość wyboru nie pokazywania wykresów czasu rzeczywistego, wyczyścić kod
    \item opracować dokumentację projektową
\end{itemize}

\Header{Wyniki:}
Kod aplikacji androidowej przeszedł solidny refactor doprowadzający go do stanu używalności. Dodana została opcja wyboru innego Pipeline jak i zmiany w GUI z tym związane. Wygląd aplikacji mógłby zostać zapewne poprawiony przez ludzi posiadających zmysł estetyczny oraz talent do organizacji niewielkich przestrzeni, jest jednak zadowalający.
By rozwiązać autoreferencję uznamy jedynie, że istnienie tego dokumentu jest dowodem na spełnienie drugiego celu tej iteracji jak i ostatniego celu całego projektu

\end{Note}

\nocite{*}
\bibliography{procesowa}
