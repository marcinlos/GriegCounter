\chapter{Cel pracy i wizja produktu}

\section{Wprowadzenie}
Wiele uwagi dzisiejszego świata poświęcone jest muzyce. Jeden z najbardziej dochodowych filarów przemysłu rozrywkowego, nieodłączny element naszego życia. Pomimo tego narzędzia do analizy muzyki są jednak w zarodku. Na palcach jednej ręki można policzyć aplikacje które są nam w stanie powiedzieć coś o pliku dźwiękowym. Dysponując telefonem z systemem Android praktycznie jedyne co jesteśmy w stanie dowiedzieć się to tytuł piosenki - pod warunkiem że zapłacimy za odpowiednią aplikację, mamy dostęp do internetu a aranżacja jest bliska oryginalnej. Co natomiast z ludźmi którzy chcieliby wiedzieć więcej? Zobaczyć falę dźwiękową, poznać tempo, być może rozpoznać gatunek bez konieczności odsłuchiwania utworu? Tą lukę postanowiliśmy wypełnić
\section{Cel i wizja}
Ostatecznym celem naszej pracy było zaprojektowanie mobilnej aplikacji będącej w stanie robić właśnie te rzeczy - wizualizować, wyciągać informacje, analizować, informować o technicznych aspektach muzyki. Wszystko to zaś zamknięte w okowach systemu operacyjnego Android. Podczas pierwszych faz developmentu odkryliśmy jednak dość nieoczekiwany fakt - Android nie implementuje wszystkich bibliotek Javy. W tym tej, która byłaby nam najbardziej potrzebna: java.sound

By temu zaradzić cel naszej pracy został lekko zmieniony. Ze względu na pozbawienie nas podstawowych niskopoziomowych narzędzi dostępu do pliku muzycznego jak i nadziei na wykorzystanie istniejących już bibliotek - postanowiliśmy zaprojektować własną. Tak narodził się Grieg, framework umożliwiający odczyt i analizę plików dźwiękowych. By zaś spełnić wymogi formalne produktu związane z tematem pracy towarzyszy mu przykładowa aplikacja korzystająca z jego możliwości, będąca prezentacją jego możliwości lecz ze względu na ograniczenia czasowe prezentująca jedynie podstawowe gotowe wyniki przetwarzania pliku muzycznego.

\section{Analiza ryzyka}
Tak postawiony cel niósł ze sobą spore ryzyko
\emph{Czas} - zakres możliwości produktu stał się bardzo szeroki, wymagający dokładnego projektowania oraz nietrywialnej implementacji wybranych rozwiązań. A deadline był sztywny. \emph{Ryzyko: 9/10}
\\
\emph{Stopień skompikowania} - żaden z nas nie miał wcześniej do czynienia z pracą nad plikami dźwiękowymi, projektowaniu frameworków a nawet doświadczenia w pisaniu aplikacji na Androida. Na naszą korzyść działała tutaj jedynie ogromna wiedza programistyczna jednego z członków zespołu \emph{Ryzyko: 8/10}
\\
\emph{Praca w zespole} - charakter członków zespołu mógł okazać się niekompatybilny. Problemy z podziałem pracy i delegacją obowiązków, niepewny zakres odpowiedzialności, problemy związane z zarządzaniem czasem. \emph{Ryzyko: 7/10} 
 
\chapter{Zakres funkcjonalności}

%nasze wymagania funkc, niefunkc

\chapter{Architektura systemu}

Projekt składa się z dwóch części: frameworku do obsługi dźwięku, oraz aplikacji Androidowej,
stanowiącej ilustrację jego możliwości i przykład użycia. Framework spełnia kilka zadań, niezbędnych
do pracy z plikami dźwiękowymi -- odpowiedzialny jest za ich wczytywanie, konwersję różnych formatów
dźwięku na ten używany wewnętrznie przez framework, oferuje także elastyczny model jego
przetwarzania oraz umożliwia jego odtwarzanie. W jego skład wchodzi kilka modułów, opisanych krótko
poniżej.

\IncludeUML{modules}{Wysokopoziomowa struktura projektu}

\section{Moduł wczytywania plików}

Jednym z zadań frameworku jest wczytywanie plików dźwiękowych i konwersja do formatu
zmiennoprzecinkowego PCM, wybranego jako wewnętrzny format reprezentacji dźwięku w całym frameworku.
\emph{Grieg} oferuje bazowo obsługę plików wav, mp3 i vorbis (ogg), jest jednak stosunkowo łatwo
rozszerzalny. Dzięki mechanizmowi pluginów i dynamicznemu ładowaniu dostępnych implementacji dodanie
obsługi kolejnego formatu nie wymaga ingerencji w kod źródłowy frameworku, a jedynie dołączenia
odpowiednich klas i pliku konfiguracyjnego do CLASSPATH-a. 

Do zaimplementowania wczytywania plików mp3 i vorbis wykorzystane zostały odpowiednie biblioteki
(\code{jlayer} dla mp3, \code{jorbis} dla ogg), natomiast parser plików wav, z uwagi na prostotę
formatu, został stworzony ręcznie. Mechanizm pluginów został stworzony przy użyciu klas stanowiących
część JDK.


\section{Moduł odczytu metadanych}

Moduł odczytu metadanych pozyskuje wszelkie informacje o utworze i reprezentującym go pliku nie
stanowiące bezpośrednio danych audio, takie jak tytuł, autor, album, rok wydania, wielkość pliku
itd. Pozwala użytkownikowi frameworku określić pożądane przez niego metadane, by uniknąć w razie
możliwości potencjalnie czasochłonnych operacji, jak również pozwala w czasie rzeczywistym
otrzymywać notyfikacje o przebiegu procesu ekstrakcji. 

Na potrzeby obsługi metadanych stworzony został prosty system ich reprezentacji, oparty na znanym
idiomie bezpiecznej heterogenicznej kolekcji, dzięki czemu pozyskane metadane są łatwe i wygodne w
użyciu.


\section{Moduł przetwarzania dźwięku}

Moduł przetwarzania dźwięku udostępnia infrastrukturę pozwalającą w dowolny sposób analizować i
przekształcać wejściowy strumień danych audio. W tym celu wykorzystuje koncept węzłów przetwarzania
-- autonomicznych jednostek, realizujących proste, atomiczne przekształcenia strumienia wejściowego
i generujących strumień wyjściowy, połączonych ze sobą wejściami/wyjściami w strukturę drzewiastą.
Rozwiązanie takie zainspirowane jest pracą prof. O. Kiselova o wielopoziomowym, inkrementalnym
przetwarzaniu danych strumieniowych, jak również podobnymi rozwiązaniami w innych bibliotekach do
przetwarzania dźwięku, takim jak Beads (\url{www.beasdsproject.net}) czy Minim
(\url{http://code.compartmental.net/tools/minim/}). Konstrukcja taka okazuje się posiadać pewne
przydatne cechy, m. in. 

\begin{itemize}

  \item modularność -- jednostki przetwarznaia są odrębne, co zmniejsza sprzężenie i minimalizuje
    wzajemne interakcje

  \item komponowalnosć -- minimalistyczna funkcjonalność ułatwia reużycie

  \item prosty, efektywny przepływ danych -- sekwencyjne przetwarzanie porcji pliku pozwala uniknąć
    konieczności przechowywania całości danych w pamięci

\end{itemize}

Infrastruktura ta domyślnie działa z elementami udostępnianymi przez moduł wczytywania plików,
jednak możliwe jest podłączenie dowolnego kompatybilnego wejścia -- implementacji stosownego
interfejsu.

Framework udostępnia kilkanaście gotowych jednostek przetwarzania, realizujących typowe, niezbyt
skomplikowane przekształcenia, np. obliczanie mocy fali, amplitudy w danym zakresie, przemnażanie
sygnału przez okno Hanninga, oraz jest obliczanie transformaty Fouriera, zrealizowane przy użyciu
biblioteki JTransforms.


\section{Moduł propagacji danych}

Moduł propagacji danych oferuje możliwość względnie prostego i wygodnego przekazania danych z
logicznej części aplikacji do interfejsu użytkownika. Celem tej części frameworku do pewnego stopnia
jest dostarczenie funkcjonalności analogicznej (choć rzecz jasna, uproszczonej) do tej znanej np. z
platformy .NET MVVM (data-binding), co pozwoliłoby elegancko odseparować warstwę prezentacji (GUI)
od kodu generującego dane. Cel ten zrealizowany został poprzez wprowadzenie hierarchicznego
\emph{modelu} danych i wzorca \emph{Observer}. Dzięki użyciu jednorodnych interfejsów i
implementacji udało się uniknąć prymitywnych rozwiązań \textit{ad-hoc}.  Framework udostępnia klasy
łączące go z modułem przetwarzania, co pozwala stworzyć np. wizualizację transformaty Fouriera
przetwarzanego sygnału w czasie rzeczywistym.


\section{Moduł odtwarzania}

Moduł odtwarzania dostarcza możliwości odtworzenia danych dźwiękowych, odczytanych z pliku bądź
przekształconych. Jest rozszerzalny -- dostępne implementacje stosownych interfejsów są dynamicznie
ładowane podczas uruchomienia na podstawie zawartości CLASSPATH-a. Jego funkcjonalność zbudowana
jest na niewielkim zestawie prostych operacji, dzięk czemu dostarczenie implementacji na nową,
niewspieraną platformę nie wymaga dużego wysiłku. Poza niskopoziomowymi szczegółami
implementacyjnymi w skład modułu wchodzi również klasa \code{Player}, udostępniająca wysokopoziomowy
interfejs do kontroli nad procesem odtwarzania. Dostępna jest implementacja oparta o
\textit{JavaSound}.


\chapter{Organizacja pracy}
Planem na organizację pracy początkowo była idea iteracji, przyrostowego modelu którego każdy cykl kończy się gotowym do zaprezentowania klientowi produktem. Po przerzuceniu ciężaru prac na budowę Frameworka okazało się to jednak w dużej mierze niemożliwe ze względu na jego zawiłą i powiązaną nawzajem budowę uniemożliwiającą działanie na wynikach cząstkowych. Stąd też jedna z iteracji zdecydowanie góruje długością nad pozostałymi ponieważ składa się na nią całość implementacji Frameworku od zera do stanu w którym był on używalny a API przyjęło ostateczną formę.

\section{Struktura zespołu}
Nasz zespół pracował w ścisłej hierarchii związanej z poziomem umiejętności. Kierownictwo przejął \emph{Marcin Łoś} - to on odpowiada za architekturę frameworku, on też zarządzał projektem od strony programistycznej delegując zadania gdzie uznał to za stosowne. \emph{Michał Torba} jako główną odpowiedzialność przyjął aplikację Androidową oraz dokumentację projektu pełniąc jedynie pomocniczą funkcję w pozostałych aspektach prac.
\section{Skrót harmonogramu}
%TODO gdy skoncze procesowa
\section{Testy jednostkowe i akceptacyjne}


%Marcinie, wiem że framework jest testowany ale not sure co dokładnie


Aplikacja Androidowa, ze względu na korzystanie z zaimplementowanych i przetestowanych już rozwiązań Frameworku poddana została jedynie testom akceptacyjnym - uruchamiana była na kilku różnych emulatorach reprezentujących różne urządzenia oparte o system Android, oraz wykorzystana do przeanalizowania różnych plików.
\section{Narzędzia}
Jako repozytorium kodu wykorzystaliśmy popularny Github. Do szybkiego tworzenia bieżącej dokumentacji projektowej korzystaliśmy z systemu Confluence udostępnianego przez Katedrę Informatyki. Specjalne podziękowanie należy się też Google Hangouts, głównej platformy komunikacji wewnątrz zespołu.

Środowiskiem budowy był Eclipse skonfigurowany pod współpracę z Android SDK. Funkcję emulatorów pełniła maszyna wirtualna wbudowana w SDK, Bluestacks będący szybką Windowsową aplikacją emulującą Androida, oraz GenyMotion czyli maszyna wirtualna systemu Android działająca pod VirtualBoxem którą można wykorzystywać dla celów niekomercyjnych do testowania aplikacji.

\chapter{Wyniki projektu}
\section{Efekty i ocena przydatności}
W ramach przyjętych założeń uzyskaliśmy zadowalające wyniki. Framework spełnia wszystkie założenia techniczne przed nim postawione, jest stosunkowo prosty w użytkowaniu i stosownie udokumentowany. O ile więc gotowe jednostki przetwarzania nie rzucą na kolana użytkowników budujących aplikację jedynie w oparciu o gotowe komponenty to jest doskonałym punktem wyjścia dla programistów pragnących napisać własne elementy analizy. Aplikacja androidowa nie posiada dużej wartości sama w sobie, natomiast dobrze demonstruje sposób wykorzystania Frameworku dając punkt wyjścia dla kolejnych bardziej dopracowanych wersji.

\section{Ograniczenia i kierunki dalszych prac}
Największym ograniczeniem jest liczba gotowych komponentów - te gotowe nie wzbudzą zachwytu w entuzjastach analizy plików muzycznych, reprezentują jedynie absolutne podstawy. Również aplikacja Androidowa ostatecznie może wymagać solidnych przeróbek jeśli nie całkowitego przepisania przez ludzi lepiej zaznajomionych z zawiłościami środowiska Androidowego.

\chapter{Bibliografia}

