
\section{Moduł przetwarzania dźwięku}

Podstawowym zadaniem frameworku jest przetwarzanie dźwięku, tj. manipulowanie jego wewnętrzną
reprezentacją, przeprowadzanie na nim różnych operacji, tworzenie w oparciu o niego innych danych,
przeprowadzanie obliczeń. Istotnym jest zatem dobranie odpowiedniego modelu przeprowadzania takich
obliczeń, który pozwoli wygodnie i efektywnie pracować z udostępnianym przez moduł wczytywania
dźwiękiem.


\subsection{Kryteria wyboru sposobu przetwarzania}

W pierwszej kolejności należy zastanowić się, jakie cechy i zachowania są pożądane, oraz jakie
ograniczenia należy nałożyć na poszukiwane rozwiązanie. Poniższa lista stanowi próbę
usystematyzowania tych rozważań, i zamknięcia ich rezultatów w klarowne, weryfikowalne punkty.

\begin{itemize}

  \item architektura systemu przetwarzania powinna być modularna -- poszczególne przekształcenia
    (obliczenia) nie powinny być trwale związane z resztą infrastruktury, idealnie byłyby osobnymi,
    niezależnymi modułami

  \item przekształcenia powinny być komponowalne -- często skomplikowane przekształcenie wyrazić
    można jako złożenie kilku prostszych. Spojrzenie takie upraszcza implementację, czyni kod
    bardziej zrozumiałym, poprawia także reużywalność kodu (zestaw niewielkich, ortogonalnych
    narzędzi sprawdza się w systemach unixowych oraz w programowaniu funkcyjnym)

  \item powinna istnieć możliwość współdzielenia wyników przekształceń -- przy organizacji opisanej
    w poprzednim podpunkcie może zdarzyć się sytuacja, że dwa różne przekształcenia będą miały część
    wspólną, przeprowadzającą takie same obliczenia na tych samych danych. Można wówczas uniknąć
    nadmiarowych obliczeń.

  \item przetwarzanie powinno być strumieniowe -- zdekompresowane pliki muzyczne są stosunkowo duże,
    a nawet jeśli przechowywanie ich w całości w pamięci jest możliwe, to zazwyczaj przetwarzane są
    sekwencyjnie, potrzeba dostępu swobodnego jest rzadka. Przetwarzanie strumieniowe nie umniejsza
    zatem znacząco możliwości, pozwala zaś obsługiwać pliki dowolnej wielkości w stałej pamięci.

  \item nie powinien przejmować pełnej kontroli nad źródłem -- powinno być możliwe przetwarzanie
    danych pochodzących np. z mikrofonu w czasie rzeczywistym (bez uprzedniego ich zapisania)

\end{itemize}


\subsection{Zastosowane rozwiązanie}

Wybrane rozwiązanie inspirowane jest pracą O. Kiselyova i stworzoną przez niego biblioteką
\emph{Iteratees}. Stanowią one wynik niezadowolenia z używanego przez bibliotekę standardową języka
Haskell modelu I/O (,,lazy IO'') i propozycję alternatywnego podejścia do obsługi wejścia\slash
wyjścia, wolnego od jego wad. Konstrukcja ta, z pewnymi zmianami, wynikającymi w dużej mierze z
odmienności paradygmatów Haskella i Javy, została użyta we frameworku jako szkielet struktury
przetwarzania danych audio.

\begin{Note}
  Nie jest to podejście zupełnie nowe -- biblioteka do przetwarzania dźwięku \emph{Beads}
  (\url{http://www.beadsproject.net/}) z powodzeniem stosuje podobną konstrukcję, choć trudno
  zakładać w tym przypadku inspirację pracą Kiselyova.
\end{Note}


Podstawę zastosowanego rozwiązania stanowi struktura drzewiasta, w której moduły odpowiedzialne za
konkretne przekształcenia strumienia wejściowego danych (nazywane dalej \emph{jednostkami
przetwarzania}), produkowanego przez moduł wczytywania plików, są liśćmi bądź węzłami wewnętrznymi.
Każdy z nich jest obiektem implementującym pewien interfejs.  Każda jednostka przetwarzania posiada
wejście określonego typu, oraz opcjonalnie wyjście -- przyjmuje strumień wejściowy, i w wyniku jego
przetwarzania mogą produkować własny strumień wyjściowy, który konsumować mogą inne jednostki.
Źródło danych produkuje strumień, którego fragmenty przekazuje do bezpośrednio dołączoncyh
jednostek. Te z kolei przekazują obliczone przez siebie wartości jednostką podłączonym do nich itd.
W ten sposób przetworzone dane propagują się przez całą strukturę. Poniższy diagram pokazuje
przykładowe drzewo.


\IncludeUML{tree_example}
{Przykładowe drzewo przetwarzania. Strzałki wskazują kierunek przepływu danych}


Statycznie, jednostki przetwarzania są od siebie zupełnie niezależne -- powiązania tworzone są
dopiero dynamicznie, podczas łączenia ich w konkretne drzewo przetwarzania. Dzięki temu zachowana
jest modularność elementów systemu przetwarzania. Możliwość dowolnego łączenia gwarantuje
komponowalność -- z prostych, reużywalnych przekształceń można swobodnie tworzyć dowolnie
skomplikowane ciągi.

Strumień przetwarzany jest inkrementalnie -- nie jest konieczne przechowywanie dużej ilości danych w
pamięci. Źródło jest w pełni autonomiczne -- jest jedynym elementem aktywnym całej struktury,
inicjuje wszelkie akcje, jakie w niej zachodzą. Pozostałe elementy drzewa nie są w żaden sposób
świadome jego istnienia i natury. Dzięki tej niezależności możliwe jest użycie jako źródła dowolnego
generatora danych, niezależnie od tego, w jaki sposób, w jakich odstępach czasu itd. produkuje dane.
Może być to prosty generator czytający kolejne fragmenty pliku audio, lub mikrofon, zbierający w
czasie rzeczywistym dźwięki z otoczenia i przekazujący je do analizy.

\begin{Note}
  Jakkolwiek system został zaprojektowany z myślą o takiej funkcjonalności, nie została ona
  ostatecznie zrealizowana.
\end{Note}


\subsection{Implementacja}

\IncludeUML{iteratee_struct}{Główne klasy rdzenia modułu przetwarzania}

\code{Enumerator} to źródło danych, producent strumienia. Umożliwia podłączenie i odłączenie ujść
danych. Wytworzone kawałki strumienia przekazuje do wszystkich przyłączonych obecnie ujść (obiektów
\code{Iteratee}) poprzez ich metodę \code{step}. W zależności od zwróconej przez nią wartości
zatrzymuje ujście (\code{State.Cont}), bądź je odłącza (\code{State.Done}). Jego implementacja jest
prosta, acz musi zawierać kilka metod, które praktycznie w każdym przypadku będą takie same, dlatego
framework udostępnia i używa wewnętrznie abstrakcyjnej klasy bazowej \code{AbstractEnumerator},
która zarządza ujściami, a także udostępnia metody pozwalające rozszerzającym ją klasom zwięźle
komunikować się z podłączonymi ujściami:

\begin{itemize}

  \item \code{pushChunk(T value)} przekazuje dołączonym ujściom wartość \code{value} (fragment
    strumienia danych), oraz obsługuje wartości zwracane przez \code{step}

  \item \code{signalFailure(Throwable e)} dla każdego przyłączonego ujścia wywołuje \code{failed},
    podając \code{e} jako argument

  \item \code{signalEndOfStream} wywołuje \code{finished} dla każdego przyłączonego ujścia

\end{itemize}

Dzięki temu, klasy rozszerzające \code{AbstractEnumerator} nie muszą implementować żadnej
funkcjonalności operującej bezpośrednio na dołączonych ujściach, co pozwala oddzielić ich faktyczną
rolę od detali implementacji interfejsu \code{Enumerator}, a także oszczędza powtarzania
identycznego boilerplate'u dla każdej klasy.


\code{Iteratee} to ujście danych, konsument strumienia. Może być przyłączony do źródła danych
(\code{Enumeratee}). Dane do konsumpcji przyjmuje poprzez metodę \code{step}, przyjmującej kolejne
fragmenty strumienia. Metoda \code{Step} zwraca wartość wyliczeniową \code{Step}, która pozwala
obiektowi zakomunikować swój stan i zamiary do źródła: \code{State.Cont} oznacza, że konsument nie
skończył jeszcze przetwarzania, i czeka na kolejną porcję danych, zaś \code{State.Done} oznacza, że
konsumpcja dobiegła końca, i obiekt nie chce już otrzymywać kolejnych ewentualnych fragmentów
strumienia, w wyniku czego powinien zostać odłączony od źródła. Podobnie jak w przypadku
\code{Enumerator}-a, istnieje abstrakcyjna klasa bazowa \code{AbstractEnumerator}, która dostarcza
puste implementacje metod \code{finished} i \code{failed}, jak również rzuca wyjątek, jeśli
\code{step} zostanie wywołany po tym, jak \code{Iteratee} zadeklaruje, że nie chce otrzymywać
kolejnych danych. Jest ona mniej przydatna niż \code{AbstractEnumerator}, nie została z tego względu
przedstawiona na diagramie.


\code{Enumeratee} to przekształcenie danych, połączenie źródła i ujścia; element ten otrzymuje na
wejściu fragmenty pewnego strumienia, konsumuje go, i na jego podstawie produkuje nowy strumień.
Istotne jest, że nowy strumień nie musi być w żaden sposób powiązany ze starym -- może być innego
typu, a przekazywanie jego fragmentów nie musi w żaden sposób być zsynchronizowane z fragmentami
strumienia wejściowego. 



\subsection{Tworzenie drzewa}


\subsection{Współpraca z modułem wczytywania danych}


\subsection{Gotowe jednostki przetwarzania}


